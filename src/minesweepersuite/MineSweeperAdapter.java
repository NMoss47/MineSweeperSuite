/*
 * MIT License
 * 
 * Copyright (c) 2018 Nicholas Moss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

package minesweepersuite;

import java.util.ArrayList;

/**
 * This class is used to act as a mediator of sorts between any view and the 
 * MineSweeper model itself. This class is the adapter part of the 
 * Model-View-Adapter (MVA) design pattern. Since it is, more or less, a 
 * Mediator pattern it shouldn't incorporate too much logic and should focus on 
 * allowing the view and model to 'communicate'.
 * 
 * I could be wrong on that. There are no hard and fast rules on what really 
 * constitutes an MVA/MVC type pattern. There are many paths to a working set of
 *  software.
 * 
 * @author Nicholas Moss
 */
public class MineSweeperAdapter implements AdapterAPI,
                                           TimerAPI{
    
    // A reference to the Model.
    private MineSweeper mineSweeper;
    // A reference to the view.
    private MineSweeperGUI mineSweeperGUI;
    // A reference to the game statistics
    private MineSweeperStatistics stats;
    
    /**
     * Default constructor. Initializes all references to null.
     */
    public MineSweeperAdapter( ) {
        mineSweeper = null;
        mineSweeperGUI = null;
        stats = null;
        
    } // End of MineSweeperAdapter( )
    
    /**
     * This function adds a model to the adapter. In this case the adapter will 
     * have a reference to the MineSweeper object.
     * 
     * @param mineSweeper The MineSweeper object of the game.
     */
    @Override
    public void addModelInstance( MineSweeper mineSweeper ) {
        this.mineSweeper = mineSweeper;
        
    } // End of addModelInstance( )
    
    /**
     * This function adds a view to the adapter. In this case the adapter will 
     * have a reference to the MineSweeperGUI object.
     * 
     * @param mineSweeperGUI The MineSweeperGUI object.
     */
    @Override
    public void addViewInstance( MineSweeperGUI mineSweeperGUI ) {
        this.mineSweeperGUI = mineSweeperGUI;
        
    } // End of addViewInstance( )
    
    /**
     * This function is used to return the adapter's reference to the model.
     * Probably bad practice to include this.
     * 
     * @return A MineSweeper object representing the model.
     */
    public MineSweeper getModel( ) {
        return mineSweeper;
        
    } // End of getModel( )
    
    /**
     * This function is used to return the adapter's reference to the view.
     * Probably bad practice to include this.
     * 
     * @return A MineSweeperGUI object representing the view.
     */
    public MineSweeperGUI getView( ) {
        return mineSweeperGUI;
        
    } // End of getView( )
    
    /**
     * This function is used to start the view/GUI.
     */
    @Override
    public void startApplication( ) { 
        mineSweeperGUI.initComponents( );
        openGameStatistics( MineSweeperIO.STATISTICS_FILE );
        
    } // End of startApplication( )
    
    /**
     * DEPRECATED. Last second change required me to not use this. It is being 
     * kept in case I figure out something better.
     * 
     * This function starts a new game by taking in a GameParameters object and 
     * passing it to the model.
     * 
     * @param params A GameParameters object containing the 
     * {mines, rows, columns} of the game (in that order). The object should be 
     * generated by the implemented view.
     */
    @Deprecated
    public void startNewGame_ORIGINAL( GameParameters params ) {
        // Generate an errorList from the setGameParams() function of the model.
        ArrayList<GameStatus> errorList = mineSweeper.setGameParams( params );
        // If the list is not null, inform the view. Otherwise set up the game.
        if( errorList != null ) {
            mineSweeperGUI.setErrors( errorList );
        }
        else {
            mineSweeperGUI.startGame( params.getRows(), params.getColumns() );
        }
        
    } // End of startNewGame( )
    
    /**
     * This function starts a new game by taking in a GameParameters object and 
     * passing it to the model.
     * 
     * @param params A GameParameters object containing the 
     * {mines, rows, columns} of the game (in that order). The object should be 
     * generated by the implemented view.
     * @return True if there were no errors, false otherwise.
     */
    @Override
    public boolean startNewGame( GameParameters params ) {
        // Generate an errorList from the setGameParams() function of the model.
        ArrayList<GameStatus> errorList = mineSweeper.setGameParams( params );
        // If the list is not null, inform the view. Otherwise set up the game.
        if( errorList != null ) {
            // Set the errors
            mineSweeperGUI.setErrors( errorList );
            return false;
        }
        // Otherwise start.
        mineSweeperGUI.startGame( params.getRows(), params.getColumns() );
        return true;
        
    } // End of startNewGame( )
    
    /**
     * This function is called when the game has been won. It checks to see if 
     * the game time is within the best ten game times. If the player was quick 
     * enough the function will call the view to display the statistics.
     * 
     * @param time The elapsed game time as a long value.
     */
    @Override
    public void winGame( long time ) {
        // Inform the GUI/view.
        mineSweeperGUI.winGame( 
                // If the user had a new best time this automagically creates 
                // A StatisticEntry object and lets the view know that it was a
                // new record.
                stats.newBestTimeAdd(time, mineSweeper.getCurrentGameParams()));
 
    } // End of winGame( )
    
    /**
     * This function should be called by the view to update some statistics 
     * with a user name.
     * 
     * @param user The name of the user as a string.
     */
    public void updateStats( String user ) {
        stats.getLastEntry().setUser( user );
        writeGameStatistics( );
        
    } // End of updateStats( )
    
    /**
     * This function is called when the game has been 'lost'.
     * 
     * @param mineLocations An int array of the locations of all of the mines.
     * @param coordinate The (x, y) coordinate of the losing move.
     */
    @Override
    public void loseGame( int[][] mineLocations, int[] coordinate ) { 
        // Inform the view of the loss and pass related information.
        mineSweeperGUI.loseGame( mineLocations, coordinate );
        
    } // End of loseGame( )
    
    /**
     * This function simply clears the game. It does not start a new one.
     */
    @Override
    public void clearGame( ) { 
        mineSweeper.clearGame( );
        mineSweeperGUI.clearGame( );
        
    } // End of clearGame( ) 
    
    /**
     * This function is used to have the model reveal any adjacent nodes.
     * 
     * @param coordinate The (x, y) coordinate of the center node.
     */
    @Override
    public void revealNearbyNodes( int[] coordinate ) { 
        mineSweeper.revealNearbyNodes( coordinate );
        
    } // End of revealNearbyNodes( )
    
    /**
     * This function is used to get the view to reveal a specific node.
     * 
     * @param coordinate The (x, y) coordinate of the node.
     */
    @Override
    public void revealNode( int[] coordinate ) {
        mineSweeperGUI.revealNode( coordinate );
        
    } // End of revealNode( )
    
    /**
     * This function is used to iterate through the Marking state of a 
     * particular coordinate.
     * 
     * @param coordinate The (x, y) coordinate of the node to be marked.
     * @return The current Marking state of the node after the state transition.
     */
    @Override
    public Marking nextMarking( int[] coordinate ) { 
        return mineSweeper.nextMarking( coordinate );
        
    } // End of nextMarking( )
    
    /**
     * This function simply calls the model's checkNode method.
     * 
     * @param coordinate The (x, y) coordinate of the node to check.
     */
    @Override
    public void checkNode( int[] coordinate ) {
        mineSweeper.checkNode( coordinate );
        
    } // End of checkNode( )
    
    /**
     * This function is used to determine if the game has been 'won'. It does 
     * this by mapping the user marked nodes to the location of mines. 
     */
    @Override 
    public void checkWinConditions( ) {
        mineSweeper.checkWinConditions( );

    } // End of checkWinConditions( )
    
    /**
     * This function is used by the view to get the game parameters set by 
     * various mode.
     * 
     * @param mode An enumeration of the mode we want.
     * @return An int array containing the { mines, rows, columns } - in order.
     */
    @Override
    public GameParameters getModeParams( Mode mode ) {
        // Based off the Mode type passed in return some set of game params.
        switch( mode ) {
            case NONE:
                return Mode.getParams( Mode.NONE );
                
            case EASY:
                return Mode.getParams( Mode.EASY );
            
            case MEDIUM:
                return Mode.getParams( Mode.MEDIUM );
                
            case HARD:
                return Mode.getParams( Mode.HARD );
                
            case RANDOM:
                return Mode.getParams( Mode.RANDOM );
        }
        // We shouldn't get here but if we do return null to break stuff.
        return null;
        
    } // End of getModeParams( )
    
    /**
     * This function simply updates the timer label in the view.
     * 
     * @param timeValue The formatted time string to update with.
     */
    @Override
    public void updateTimer( String timeValue ) {
        mineSweeperGUI.updateTimer( timeValue );
    
    } // End of updateTimer( )
    
    /**
     * This function is used to pause the game.
     */
    @Override
    public void pauseGame( ) {
        mineSweeper.getTimer( ).pauseGame( );
        
    } // End of pauseGame( )
    
    /**
     * This function is used to determine if the game is paused.
     * 
     * @return True if paused, false otherwise.
     */
    @Override
    public boolean isPaused( ) {
        return mineSweeper.getTimer( ).isPaused( );
        
    } // End of getPausedStatus( )
    
    /**
     * This function is used to stop the game.
     */
    @Override
    public void stopGame( ) {
        // The game might not have been fully initialized.
        // If the timer is null just dip out.
        if( mineSweeper.getTimer() == null ) return;
        mineSweeper.getTimer( ).stopGame( );
        
    } // End of stopGame( )
    
    /**
     * This function is used to resume a game after it is paused.
     */
    @Override
    public void resumeGame( ) {
        mineSweeper.getTimer( ).resumeGame( );
        
    } // End of resumeGame( )
    
    /**
     * This function is used to give the view the proximity count of a specific 
     * node.
     * 
     * @param coordinate The (x, y) coordinate of the node.
     * @param prox The proximity count of the node.
     */
    public void setNodeProx( int[] coordinate, int prox ) {
        mineSweeperGUI.setNodeProx( coordinate, prox );
        
    } // End of setNodeProx( )
    
    /**
     * This function updates the view with the current amount of marked nodes.
     * 
     * @param markingCount The current number of marked nodes.
     * @param totalMines The total number of mines in the game.
     */
    public void setViewMarkingCount( int markingCount, int totalMines ) {
        mineSweeperGUI.setMarkingCount( markingCount, totalMines );
        
    } // End of setViewMarkingCount( )
    
    /**
     * This function returns a reference to the MineSweeperStatistics object.
     * 
     * @return A MineSweeperStatistics object.
     */
    public MineSweeperStatistics getGameStatistics( ) {
        return stats;
        
    } // End of getGameStatistics( )
    
    /**
     * This function tries to open a file containing the MineSweeperStatistics 
     * object. If the file reading fails we just make a new one.
     * 
     * @param file A string of the file path.
     */
    public void openGameStatistics( String file ) {
        stats = (MineSweeperStatistics)MineSweeperIO.readObjectFromFile( file );
        if( stats == null )
            stats = new MineSweeperStatistics( );
        
    } // End of openGameStatistics( )
    
    /**
     * Writes a new or updated MineSweeperStatistics list to a file.
     */
    public void writeGameStatistics( ) {
        MineSweeperIO.writeObjectToFile( stats, MineSweeperIO.STATISTICS_FILE );
        
    } // End of writeGameStatistics( )
    
} // End of MineSweeperAdapter class.
